---
layout: post
tag: Python
---

机器学习对内存的消耗是比较大的，当你没钱给服务器升配置时就会深刻感受到这个问题，这时候内存优化就显得很有必要。

在进行内存优化之间首先要依次明确两个问题：

1. 是否真实存在内存使用性能低下
2. 性能瓶颈出现在程序的哪个部分

通常第一个问题比较明显，当操作系统显示运行程序的进程的内存占用达到机器的80％时就要注意了，不然继续增加功能或测试数据量的话分分钟爆内存。接下来就可以对性能瓶颈进行定位了。

存储性能问题和时间性能问题一样，都需要通过profile来定位。在Python中常用的内存profile工具是memory_profiler，可以用PIP进行安装。但这并不是本文的重点，重点是，用Python做机器学习应用一般可以从以下几个方面入手避免出现存储性能问题，这样就可以减少后期做profile和优化的时间。

#### 选用适用于数值集合的数据结构

比如list和array。在有监督学习中将训练数据中的真实标签从文件读入内存时，一般需要扫描训练数据的各行将其中的真实类别追加到y里面。

考虑到追加元素的速度，很可能会不小心选用list作为y在内存中的结构。这是一种比较浪费内存的做法。因为list本身占用连续内存块，其中的各个单元所存储的是真实元素对象的指针，所有的真实元素对象在另外的地方独立存在。比如list中的元素为整型，若要追加一个值为v的元素，而且内存中不存在值为v的整型对象，那么会在内存中创建一个新的整型对象其中值为v，而Python中一个整型对象在64位系统上占用24个字节，其中包括真实数据对象、引用、引用计数，真实数据对象设置为长整型，因此占64位即8个字节，引用和引用计数大小取决于操作系统，在64位系统上分别占8个字节。同时，list本身所存储的引用也会占用内存。

显然y是作为一个整体被使用的，因为其中的各个元素只需要用到真实的数据对象，即一个整型中的其中8位，其它的2/3都是在浪费内存空间。所以应该用array而不是list。array是一个类似list的容器，同样是占据连续的内存块、同样会动态增长因此均摊插入效率也是$$O(1)$$，最大的区别是array的各个存储单元是直接存储真实数据对象的，以64位整数为例，array中各个存储单元为8个字节用于存储一个64位整数，相当于list中实际存储的一个引用。

因此，同样的数据用array来存储所节省的空间是list额外用于存储真实数据对象的空间。

同样的情况还可能发生在初始化一个scipy.sparse模块中稀疏矩阵的情况下。因为大部分稀疏矩阵的数据成员是类似数组的结构，这时选用array或ndarray是比较紧凑的。

在numpy和scipy中定义的数据结构显然比较适用于数值集合，一般会优先考虑选用。

#### 避免不必要的复制

这具体经常发生在以下两种情况：

1. 对容器中的值进行修改

比如在估计线性形式的朴素贝叶斯的类别先验分布时，需要先计算出各个类别的频率，再对频率取对数。实际上"各个类别的频率"只是一个中间过程，
自定义ufunc


2. 取numpy或scipy中一些容器的子集
假设某个函数需要对spase.csr_matrix对象进行按行扫描，这时候一个很自然的想法是调用get_row()方法，传入的参数为各行行号。
