---
layout: post
tag: Python
---

多态是面向对象编程的一个重要特性，目的在于提高程序的可扩展性，即当需要对多个相似的对象发送同一个消息时，只需要将消息定义在这些对象的基类地址上，之后调用函数时传入任意一个派生类地址时，消息都能按特定派生类的定义来响应。
以机器学习系统为例，假设有多个类型分别代表不同的模型，另外有一个train函数完成模型的拟合和预测过程。这时候train函数就是需要对不同的模型对象发送的消息，各个模型是"多个相似的对象"。
要用C++实现这样的功能，步骤和代码如下：

1. 将不同模型的基类定义为纯抽象基类（ModelBase），"拟合"（fit）和"预测"（predict）定义为纯虚函数
2. 定义多个继承这个纯抽象基类的派生类（LogisticRegression 和 NaiveBayes），对"拟合"和"预测"方法进行重写
3. 定义train函数，参数为纯抽象基类的地址（void train(ModelBase &model_base)）

{% highlight cpp %}
#include <iostream>

//定义纯抽象基类ModelBase, 其中fit和predict均为纯虚函数

class ModelBase {
public:
    virtual void fit() = 0;
    virtual void predict() = 0;
};

//ModelBase的子类

class LogisticRegression : public ModelBase {
public:

    void fit() {
        std::cout << "fit by lr" << std::endl;
    }

    void predict() {
        std::cout << "predict by lr" << std::endl;
    }
};

class NaiveBayes : public ModelBase {
public:

    void fit() {
        std::cout << "fit by nb" << std::endl;
    }

    void predict() {
        std::cout << "predict by nb" << std::endl;
    }
};

//给ModelBase发送消息的train()函数

void train(ModelBase &model_base) {
    model_base.fit();
    model_base.predict()
};

//入口函数

int main(int argc, char** argv) {
    LogisticRegression lr;
    NaiveBayes nb;
    train(lr);
    train(nb);
    return 0;
}
{% endhighlight %}

于是在main函数中无论是传入LogisticRegression还是NaiveBayes的对象，在调用train()时都能正确地调用基类所重写的方法。同时，这里的纯抽象基类ModelBase是无法被实例化的，只要基类中有任意一个函数是纯虚函数，它都无法被实例化。

Python作为面向对象语言自然也会有多态的特性，但另一方面它也是动态编译语言，定义函数时不需要预先指定参数类型。因此，在Python中实现多态并不需要抽象基类（事实上在Python抽象基类的官方文档中也有写明说"C++ programmers should note that Python’s virtual base class concept is not the same as C++’s."）
在Python中实现多态所用的是duck typing. 延续以上例子，即只需要独立定义类LogisticRegression和NaiveBayes，或者更多的其它模型对应的类型，这些类型之间不需要同为某抽象基类的派生类，只需要都定义了"fit"和"predict"两个名字的接口，这样向train函数传入任意一个有"fit"和"predict"接口的对象，代码都能正确地运作。

{% highlight python %}
class LogisticRegression:
    def fit(self):
        print "fit by lr"

    def predict(self):
        print "predict by lr"


class NaiveBayes:
    def fit(self):
        print "fit by nb"

    def predict(self):
        print "predict by nb"


def train(model):
    model.fit()
    model.predict()


if __name__ == '__main__':
    lr = LogisticRegression()
    nb = NaiveBayes()
    train(lr)
    train(nb)
{% endhighlight %}

